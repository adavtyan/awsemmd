#!/usr/bin/env python

"""
This script reads the 3spn2_conf_lammps.in file and generates
list files for use with the list bond_style, angle_style, and dihedral_styles
in LAMMPS.

NOTE: The conf_lammp.in should be generated by icnf.exe with the flag
indicating that curved dsDNA is desired, in order for correct values of base
stacking parameters to be included in conf_lammps.in.
"""

import sys, math
from CurvParams import *

# Defining a few constant values
siteDict = {
    1:"P",
    2:"S",
    3:"A",
    4:"T",
    5:"G",
    6:"C",
    7:"A",
    8:"T",
    9:"G",
    10:"C",
    11:"A",
    12:"T",
    13:"G",
    14:"C"
}

baseDict = {"A":0,"T":1,"C":2,"G":3}
FOUR = 4
THREE = 3
kJ2kCal = 1.0/4.184

# Defining classes to facilitate analysis
class Atom:
    def __init__(self,mol,type,x,y,z):
        self.mol = mol
        self.type = type
        self.x = x
        self.y = y
        self.z = z

class Bond:
    def __init__(self,type,a,b):
        self.type = type
        self.a = a
        self.b = b

class Angle:
    def __init__(self,type,a,b,c):
        self.type = type
        self.a = a
        self.b = b
        self.c = c

class Dihedral:
    def __init__(self,type,a,b,c,d):
        self.type = type
        self.a = a
        self.b = b
        self.c = c
        self.d = d


class LmpConf:
    def __init__(self,confFile):
        self.xlo = None
        self.xhi = None
        self.ylo = None
        self.yhi = None
        self.zlo = None
        self.yhi = None
        self.nAtoms = None
        self.nBonds = None
        self.nAngles = None
        self.nDihedrals = None
        self.confFile = confFile
        self.atoms = []
        self.bonds = []
        self.angles = []
        self.dihedrals = []
        self.blen = []
        self.bhlf = []
        self.blni = []

    def initialize_box(self,xlo,xhi,ylo,yhi,zlo,zhi):
        self.blen.append(abs(xhi-xlo))
        self.blen.append(abs(yhi-ylo))
        self.blen.append(abs(zhi-zlo))
        for i in range(THREE):
            self.bhlf.append(self.blen[i]/2.0)
            self.blni.append(1.0/self.blen[i])
    def apply_pbcs(self,dr,dim):
        if dr > self.bhlf[dim]:
            dr = dr - self.blen[dim] * float(int(dr * self.blni[dim] + 0.5))
        elif dr < -self.bhlf[dim]:
            dr = dr - self.blen[dim] * float(int(dr * self.blni[dim] - 0.5))
        return dr

    def write_bond_list(self, prot_atom_num):
        filename = "in00_bond.list"
        file = open(filename,"w")
        #file.write("%d\n" % self.nBonds)
        for i in range(self.nBonds):
            b = self.bonds[i]
            r = self.calculate_bond_distance(b.a,b.b)
            file.write("%ld\t%ld\t%lf\t%lf\t%lf\t%lf\n" % (b.a+prot_atom_num,b.b+prot_atom_num,r,kbond*kJ2kCal,0.0,100*kbond*kJ2kCal))
        file.close()

    def write_angle_list(self, prot_atom_num):
        filename = "in00_angl.list"
        file = open(filename,"w")
        #file.write("%d\n" % self.nAngles)
        for i in range(self.nAngles):
            a = self.angles[i]
            # Determine the angle type to use
            typea = siteDict[self.atoms[a.a-1].type]
            typeb = siteDict[self.atoms[a.b-1].type]
            typec = siteDict[self.atoms[a.c-1].type]

            if typea in baseDict and typeb is "S" and typec is "P":
                neighborType = siteDict[self.atoms[a.a-1+THREE].type]
                kbend = BSP[typea][neighborType]

            if typea in "P" and typeb is "S" and typec in baseDict:
                neighborType = siteDict[self.atoms[a.c-1-THREE].type]
                kbend = PSB[typec][neighborType]

            if typea in "P" and typeb is "S" and typec is "P":
                neighborType = siteDict[self.atoms[a.b-1+1].type]
                kbend = PSP[neighborType][neighborType] # This force constant is constant for all PSP angles

            if typea is "S" and typeb is "P" and typec is "S":
                neighborType1 = siteDict[self.atoms[a.a-1+1].type]
                neighborType2 = siteDict[self.atoms[a.c-1+1].type]
                kbend = BSP[neighborType1][neighborType2]
            theta = self.calculate_bend_angle(a.a,a.b,a.c)

            # Only write if angle is type 1 (list)
            if a.type == 1:
                file.write("%ld\t%ld\t%ld\t%lf\t%lf\n" % (a.a+prot_atom_num,a.b+prot_atom_num,a.c+prot_atom_num,theta,kbend*kJ2kCal))
        file.close()

    def write_dihedral_list(self, prot_atom_num):
        filename = "in00_dihe.list"
        file = open(filename,"w")
        #file.write("%d\n" % self.nDihedrals)
        for i in range(self.nDihedrals):
            d = self.dihedrals[i]
            # Determine the angle type to use
            typea = siteDict[self.atoms[d.a-1].type]
            typeb = siteDict[self.atoms[d.b-1].type]
            typec = siteDict[self.atoms[d.c-1].type]
            typed = siteDict[self.atoms[d.d-1].type]

            if typea is "P" and typeb is "S" and typec is "P" and typed is "S":
                dihedral_type = 2
            elif typea is "S" and typeb is "P" and typec is "S" and typed is "P":
                dihedral_type = 2
            else :
                dihedral_type = 1
            phi = self.calculate_dihedral_angle(d.a,d.b,d.c,d.d)
            phi -= 180.0
            # Write the periodic diheral (Note new style!)
            file.write("%ld\t%ld\t%ld\t%ld\t%lf\t%lf\t%lf\t%lf\t%d\n" % (d.a+prot_atom_num,d.b+prot_atom_num,d.c+prot_atom_num,d.d+prot_atom_num,phi,kperiodic*kJ2kCal, kgauss*kJ2kCal, sigma, dihedral_type))
        file.close()

    def calculate_bend_angle(self,stea,steb,stec):
        a = self.atoms[stea-1]
        b = self.atoms[steb-1]
        c = self.atoms[stec-1]
        dab = [a.x - b.x, a.y - b.y, a.z - b.z]
        dbc = [c.x - b.x, c.y - b.y, c.z - b.z]
        for i in range(THREE):
            dab[i] = self.apply_pbcs(dab[i],i)
            dbc[i] = self.apply_pbcs(dbc[i],i)

        eabx = []
        ebcx = []
        dabi = 1.0/ math.sqrt(dab[0] * dab[0] + dab[1] * dab[1] + dab[2] * dab[2])
        for i in range(THREE):
            eabx.append(dab[i] * dabi)
        dbci = 1.0/ math.sqrt(dbc[0] * dbc[0] + dbc[1] * dbc[1] + dbc[2] * dbc[2])
        for i in range(THREE):
            ebcx.append(dbc[i] * dbci)
        cphi = 0.0
        for i in range(THREE):
            cphi += eabx[i] * ebcx[i]
        if cphi > 0.9999:
            cphi = 0.9999
        if cphi < -0.9999:
            cphi = -0.9999
        athe = math.acos(cphi)
        return athe / math.pi * 180.0

    def calculate_dihedral_angle(self,stea,steb,stec,sted):
        a = self.atoms[stea-1]
        b = self.atoms[steb-1]
        c = self.atoms[stec-1]
        d = self.atoms[sted-1]
        dab = [b.x - a.x, b.y - a.y, b.z - a.z]
        dbc = [c.x - b.x, c.y - b.y, c.z - b.z]
        dcd = [d.x - c.x, d.y - c.y, d.z - c.z]
        for i in range(THREE):
            dab[i] = self.apply_pbcs(dab[i],i)
            dbc[i] = self.apply_pbcs(dbc[i],i)
            dcd[i] = self.apply_pbcs(dcd[i],i)

        eabx = []
        ebcx = []
        ecdx = []
        dabi = 1.0/ math.sqrt(dab[0] * dab[0] + dab[1] * dab[1] + dab[2] * dab[2])
        for i in range(THREE):
            eabx.append(dab[i] * dabi)
        dbci = 1.0/ math.sqrt(dbc[0] * dbc[0] + dbc[1] * dbc[1] + dbc[2] * dbc[2])
        for i in range(THREE):
            ebcx.append(dbc[i] * dbci)
        dcdi = 1.0/ math.sqrt(dcd[0] * dcd[0] + dcd[1] * dcd[1] + dcd[2] * dcd[2])
        for i in range(THREE):
            ecdx.append(dcd[i] * dcdi)

        # Shamelessly copied from 3SPN.2 source
        pacx = eabx[1] * ebcx[2] - eabx[2] * ebcx[1]
        pacy = eabx[2] * ebcx[0] - eabx[0] * ebcx[2]
        pacz = eabx[0] * ebcx[1] - eabx[1] * ebcx[0]
        cosb = -(eabx[0] * ebcx[0] + eabx[1] * ebcx[1] + eabx[2] * ebcx[2])
        isb2 = 1.0 / (1.0 - cosb * cosb)
        isnb = math.sqrt(isb2)

        pbdx = ecdx[1] * ebcx[2] - ecdx[2] * ebcx[1]
        pbdy = ecdx[2] * ebcx[0] - ecdx[0] * ebcx[2]
        pbdz = ecdx[0] * ebcx[1] - ecdx[1] * ebcx[0]
        cosc = -(ecdx[0] * ebcx[0] + ecdx[1] * ebcx[1] + ecdx[2] * ebcx[2])
        isc2 = 1.0 / (1.0 - cosc * cosc)
        isnc = math.sqrt(isc2)

        padx = -(pacy * pbdz - pacz * pbdy)
        pady = -(pacz * pbdx - pacx * pbdz)
        padz = -(pacx * pbdy - pacy * pbdx)
        cnum = (padx * ebcx[0] + pady * ebcx[1] + padz * ebcx[2])

        ctau = -(pacx * pbdx + pacy * pbdy + pacz * pbdz) * isnb * isnc
        if ctau > 1.0:
            ctau = 1.0
        if ctau < -1.0:
            ctau = -1.0
        aphi = math.acos(ctau)
        if cnum < 0.0:
            aphi = -aphi
        return aphi / math.pi * 180.0

    def calculate_bond_distance(self,stea,steb):
        a = self.atoms[stea-1]
        b = self.atoms[steb-1]
        dx = [a.x - b.x, a.y - b.y, a.z - b.z]
        for i in range(THREE):
            dx[i] = self.apply_pbcs(dx[i],i)
        r = math.sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2])
        return r

    def read_configuration_file(self):
        try:
            file = open(self.confFile,"r")
            line = file.readline()
            while line:
                if "atoms" in line:
                    self.nAtoms = int(line.strip().split()[0])
                if "bonds" in line:
                    self.nBonds = int(line.strip().split()[0])
                if "angles" in line:
                    self.nAngles = int(line.strip().split()[0])
                if "dihedrals" in line:
                    self.nDihedrals = int(line.strip().split()[0])
                if "xlo xhi" in line:
                    xlo = float(line.strip().split()[0])
                    xhi = float(line.strip().split()[1])
                if "ylo yhi" in line:
                    ylo = float(line.strip().split()[0])
                    yhi = float(line.strip().split()[1])
                if "zlo zhi" in line:
                    zlo = float(line.strip().split()[0])
                    zhi = float(line.strip().split()[1])
                if "Atoms" in line:
                    file.readline()
                    for i in range(self.nAtoms):
                        l = file.readline().strip().split()
                        self.atoms.append(Atom(int(l[1]),int(l[2]),float(l[4]), float(l[5]),float(l[6])))
                if "Bonds" in line:
                    file.readline()
                    for i in range(self.nBonds):
                        l = file.readline().strip().split()
                        self.bonds.append(Bond(int(l[1]),int(l[2]),int(l[3])))

                if "Angles" in line:
                    file.readline()
                    for i in range(self.nAngles):
                        l = file.readline().strip().split()
                        self.angles.append(Angle(int(l[1]),int(l[2]),int(l[3]),int(l[4])))

                if "Dihedrals" in line:
                    file.readline()
                    for i in range(self.nDihedrals):
                        l = file.readline().strip().split()
                        self.dihedrals.append(Dihedral(int(l[1]),int(l[2]),int(l[3]),int(l[4]),int(l[5])))
                line = file.readline()

        except IOError:
            print ("Count not open %s" % self.confFile)
            sys.exit(2)
        self.initialize_box(xlo,xhi,ylo,yhi,zlo,zhi)


def get_command_line_args(args):
    if len(args) != 3:
        print ("Usage: %s <LAMMPS configuation file> <protein atom number>" % args[0])
        sys.exit(1)
    return args[1]

def main():
    configurationFile = get_command_line_args(sys.argv)
    lmpconf = LmpConf(configurationFile)
    lmpconf.read_configuration_file()
    prot_atom_num = int(sys.argv[2])
    lmpconf.write_bond_list(prot_atom_num)
    lmpconf.write_angle_list(prot_atom_num)
    lmpconf.write_dihedral_list(prot_atom_num)

if __name__ == "__main__":
    main()
